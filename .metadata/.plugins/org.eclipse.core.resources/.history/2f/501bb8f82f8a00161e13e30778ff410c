package Juego;

import java.awt.BorderLayout;
import java.awt.Canvas;
import java.awt.Dimension;

import javax.swing.JFrame;

//creamo la clase juego le decimos que es un Canvas y le implementamos una interfaz Runnable 
//para poder usar diferentes threads para agilizar los procesos
public class Juego extends Canvas implements Runnable {

	// añade una id para futuros cambios (se puede hacer al pulsar sobre la
	// clase publica Juego)
	private static final long serialVersionUID = 1L;

	// constantes para decir el alto y ancho de nuestra ventana
	private static final int ANCHO = 800;
	private static final int ALTO = 600;

	// booleano para comprobar el correcto funcionamiento del juego (le decimos
	// que es volatile para que solo lo pueda usar 1 thread a la vez)
	private static volatile boolean enFuncionamiento = false;

	// nombre para la ventana
	private static final String NOMBRE = "Juego";

	// para añadir la ventana (se necesita importar el Jframe)
	private static JFrame ventana;

	// crear segundo thread
	private static Thread thread;

	private Juego() {

		// tamaño que tendra nuestra ventana
		setPreferredSize(new Dimension(ANCHO, ALTO));

		// iniciar objeto ventana
		ventana = new JFrame(NOMBRE);
		// establecer que al pulsar el boton cerrar se ciera la ventana
		ventana.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		// el usuario no pueda cambiar el tamaño de la ventana
		ventana.setResizable(false);
		// diseño de la ventana o organizacion interna, abra ke importarlo
		ventana.setLayout(new BorderLayout());
		// añadir a la ventana nuestra clase Juego es decir el Canvas y lo
		// centramos en mitad de la pantalla
		ventana.add(this, BorderLayout.CENTER);
		// para ajustar el contenido de la ventana al tamaño ke keremos
		ventana.pack();
		// fijar la ventaña en mitad del escritorio
		ventana.setLocationRelativeTo(null);
		// para ke la ventana sea visible
		ventana.setVisible(true);
	}

	// metodo main para poder ejecutar el programa
	public static void main(String[] args) {
		Juego juego = new Juego();
		// ejecuta el metodo "iniciar"
		juego.iniciar();
	}

	// metodo para iniciar el segundo thread (le decimos synchronized para que
	// se asegure que los metodos inicar y detener no puedan cambiar las
	// variables de forma simultanea)
	private synchronized void iniciar() {
		// cambia el valor a true para comprobar que se esta ejecutando
		enFuncionamiento = true;

		// iniciamos el thread y lo identificamos como Graficos
		thread = new Thread(this, "Graficos");
		// poner en ejecucion el thread
		thread.start();

	}

	// metodo para detener el segundo thread (synchronized ver metodo inicar)
	private synchronized void detener() {
		// cambia a false para comprobar que se detuvo
		enFuncionamiento = false;

		// intenta detener el thread de forma segura
		try {
			// detiene el thread (usando join() nos aseguramos que el thread
			// acabe de hacer lo que estaba haciendo antes de cerrarlo)
			thread.join();
		} catch (InterruptedException e) {
			// nos muestra por consola el error si no consigue detener
			e.printStackTrace();
		}

	}

	// metodo para actualizar las variables del juego: vida de jugador, objetos,
	// etc..
	private void actualizar() {

	}

	// metodo para redibujar los graficos del juego
	private void mostrar() {

	}

	// es lo que ejecutara el segundo thread (ver class Juego (implements
	// Runnable))
	public void run() {
		// comprueba que se esta ejecutando el segundo thread
		/* System.out.print("El thread 2 se esta ejecutando"); */

		// mientras enFuncioamiento sea verdadero se ejecutara lo siguiente
		while (enFuncionamiento) {
			actualizar();
			mostrar();
		}
	}
}
